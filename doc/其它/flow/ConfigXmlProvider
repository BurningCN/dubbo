dubbo-samples CacheProvider
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("samples.cache/cache-provider.xml");
context.start();

System.out.println("dubbo service started");
new CountDownLatch(1).await();

<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <context:property-placeholder/>

    <dubbo:application name="cache-provider"/>

    <dubbo:registry address="zookeeper://${zookeeper.address:127.0.0.1}:${zookeeper.port:2181}"/>

    <dubbo:protocol name="dubbo" port="20880"/>

    <bean id="cacheService" class="samples.cache.impl.CacheServiceImpl"/>

    <dubbo:service interface="samples.cache.api.CacheService" ref="cacheService"/>

</beans>

// ====================================================================

resources
	
	META-INF
		compat
			dubbo.xsd

	dubbo.internal		
	
	spring.handlers
		http\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd

	spring.schemas
		http\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler

// ====================================================================
DubboNamespaceHandler extends NamespaceHandlerSupport implements ConfigurableSourceBeanMetadataElement {

	static {
        
        Version.checkDuplicate(DubboNamespaceHandler.class);
        	
        	checkDuplicate(cls, false);
        		 
        		 checkDuplicate(cls.getName().replace('.', '/') + ".class", failOnError);
        		 	
        		 	checkDuplicate(String path, boolean failOnError)
	        		 	
	        		 	Set<String> files = getResources(path);
	        		 		
	        		 		Enumeration<URL> urls = ClassUtils.getCallerClassLoader(Version.class).getResources(path);
					        
					        Set<String> files = new HashSet<String>();
					        
					        while (urls.hasMoreElements()) {
					            URL url = urls.nextElement();
					            if (url != null) {
					                String file = url.getFile();
					                if (StringUtils.isNotEmpty(file)) {
					                    files.add(file);
					                }
					            }
					        }
					        return files;
			            
			            // duplicated jar is found
			            if (files.size() > 1) {
			                String error = "Duplicate class " + path + " in " + files.size() + " jar " + files;
			                if (failOnError) {
			                    throw new IllegalStateException(error);
			                } else {
			                    logger.error(error);
			                }
			            }
    }


    NamespaceHandler init

    @Override
    public void init() {
        
        registerBeanDefinitionParser("application", new DubboBeanDefinitionParser(ApplicationConfig.class, true));

        	DubboBeanDefinitionParser(Class<?> beanClass, boolean required)
	        	this.beanClass = beanClass;
	        	this.required = required;
        
        registerBeanDefinitionParser("module", new DubboBeanDefinitionParser(ModuleConfig.class, true));
        registerBeanDefinitionParser("registry", new DubboBeanDefinitionParser(RegistryConfig.class, true));
        registerBeanDefinitionParser("config-center", new DubboBeanDefinitionParser(ConfigCenterBean.class, true));
        registerBeanDefinitionParser("metadata-report", new DubboBeanDefinitionParser(MetadataReportConfig.class, true));
        registerBeanDefinitionParser("monitor", new DubboBeanDefinitionParser(MonitorConfig.class, true));
        registerBeanDefinitionParser("metrics", new DubboBeanDefinitionParser(MetricsConfig.class, true));
        registerBeanDefinitionParser("ssl", new DubboBeanDefinitionParser(SslConfig.class, true));
        registerBeanDefinitionParser("provider", new DubboBeanDefinitionParser(ProviderConfig.class, true));
        registerBeanDefinitionParser("consumer", new DubboBeanDefinitionParser(ConsumerConfig.class, true));
        registerBeanDefinitionParser("protocol", new DubboBeanDefinitionParser(ProtocolConfig.class, true));
        registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
        registerBeanDefinitionParser("reference", new DubboBeanDefinitionParser(ReferenceBean.class, false));
        registerBeanDefinitionParser("annotation", new AnnotationBeanDefinitionParser());
        	
        	AnnotationBeanDefinitionParser extends AbstractSingleBeanDefinitionParser 
        		
        		doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)
	        		String packageToScan = element.getAttribute("package");

			        String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));

			        builder.addConstructorArgValue(packagesToScan);

			        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

			    protected Class<?> getBeanClass(Element element) {
        			return ServiceAnnotationBeanPostProcessor.class;
    			} 
    }

	@Override
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        
        BeanDefinitionRegistry registry = parserContext.getRegistry();
        
        registerAnnotationConfigProcessors(registry);
        	AnnotationConfigUtils.registerAnnotationConfigProcessors(registry);
        
        registerCommonBeans(registry);
        	        
        	        registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME,
                			ReferenceAnnotationBeanPostProcessor.class);

			        registerInfrastructureBean(registry, DubboConfigAliasPostProcessor.BEAN_NAME,
			                DubboConfigAliasPostProcessor.class);
					
					registerInfrastructureBean(registry, DubboApplicationListenerRegistrar.BEAN_NAME,
			                DubboApplicationListenerRegistrar.class);
			        
			        registerInfrastructureBean(registry, DubboConfigDefaultPropertyValueBeanPostProcessor.BEAN_NAME,
			                DubboConfigDefaultPropertyValueBeanPostProcessor.class);
			        
			        registerInfrastructureBean(registry, DubboConfigEarlyInitializationPostProcessor.BEAN_NAME,
			                DubboConfigEarlyInitializationPostProcessor.class);
        
        BeanDefinition beanDefinition = super.parse(element, parserContext);
       		// 另换行

        setSource(beanDefinition);
        	ConfigurableSourceBeanMetadataElement setSource(BeanMetadataElement beanMetadataElement)
	        	if (beanMetadataElement instanceof BeanMetadataAttributeAccessor) {
		            BeanMetadataAttributeAccessor.class.cast(beanMetadataElement).setSource(this);
		        }
        
        return beanDefinition;
    }

DubboBeanDefinitionParser parse(Element element, ParserContext parserContext) {
	return parse(element, parserContext, beanClass, required);
		RootBeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required)
		// todo 
	

上面parse全部解析完成，走BeanFactoryPostProcessor相关及调用顺序，如下
// ====================================================================

DubboConfigEarlyInitializationPostProcessor 
	PriorityOrdered getOrder
		return HIGHEST_PRECEDENCE;

	BeanDefinitionRegistryPostProcessor postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
		
		this.beanFactory = unwrap(registry);
			if (registry instanceof DefaultListableBeanFactory) {
	            return (DefaultListableBeanFactory) registry;
	        }
	        return null;
        
        initBeanFactory();
        	if (beanFactory != null) {
	            // Register itself
	            if (logger.isInfoEnabled()) {
	                logger.info("BeanFactory is about to be initialized, trying to resolve the Dubbo Config Beans early " +
	                        "initialization");
	            }
	            beanFactory.addBeanPostProcessor(this);
	        }

DubboConfigAliasPostProcessor
	BeanDefinitionRegistryPostProcessor postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
		this.registry = registry;


DubboConfigEarlyInitializationPostProcessor 
	BeanFactoryPostProcessor
		postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
			if (beanFactory == null) { // try again if postProcessBeanDefinitionRegistry method does not effect.
	            this.beanFactory = unwrap(beanFactory);
	            initBeanFactory();
	        }
DubboConfigAliasPostProcessor
	BeanFactoryPostProcessor
			postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
				// DO NOTHING

// ====================================================================
DubboConfigEarlyInitializationPostProcessor 
	PriorityOrdered getOrder
		return HIGHEST_PRECEDENCE;


容器初始话完成后如下 
// ====================================================================
ReferenceAnnotationBeanPostProcessor setApplicationContext

DubboApplicationListenerRegistrar implements ApplicationContextAware
	
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (!isAssignable(ConfigurableApplicationContext.class, applicationContext.getClass())) {
            throw new IllegalArgumentException("The argument of ApplicationContext must be ConfigurableApplicationContext");
        }
        addApplicationListeners((ConfigurableApplicationContext) applicationContext);
        	// 不赘述，详见 ConfigAnnotationProvider 搜 DubboApplicationListenerRegistrar
    }

容器初始话完成后 BeanPostProcessor 相关 如下 (下面这段逻辑不太正常，可以不看)
// ====================================================================

触发下面的逻辑的bean为dubboApplicationListener

DubboConfigAliasPostProcessor 

	BeanPostProcessor postProcessBeforeInitialization
		public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
	        // DO NOTHING
	        return bean;
	    }
	BeanPostProcessor postProcessAfterInitialization
		if (bean instanceof AbstractConfig) {
            String id = ((AbstractConfig) bean).getId();
            if (hasText(id)                                     // id MUST be present in AbstractConfig
                    && !nullSafeEquals(id, beanName)            // id MUST NOT be equal to bean name
                    && !hasAlias(registry, beanName, id)) {     // id MUST NOT be present in AliasRegistry
                registry.registerAlias(beanName, id);
            }
        }
        return bean;

// ****1 ====================================================================
// 构造方法触发，不过注意这个对象正在初始化， this断点会提示object is being initialized
public ApplicationConfig() {

}


BeanPostProcessor 相关 前置逻辑
// ====================================================================
DubboConfigEarlyInitializationPostProcessor 
	GenericBeanPostProcessorAdapter processBeforeInitialization(AbstractConfig config, String beanName) 
		if (this.beanFactory == null) {
            if (logger.isErrorEnabled()) {
                logger.error("Current Processor is not running in Spring container, next action will be skipped!");
            }
            return;
        }

        // If CommonAnnotationBeanPostProcessor is already registered,  the method addIntoConfigManager()
        // will be invoked in Bean life cycle.
        if (!hasRegisteredCommonAnnotationBeanPostProcessor()) {

        	hasRegisteredCommonAnnotationBeanPostProcessor
        		
        		for (BeanPostProcessor beanPostProcessor : beanFactory.getBeanPostProcessors()) {
		            if (CommonAnnotationBeanPostProcessor.class.equals(beanPostProcessor.getClass())) {
		                return true;
		            }
		        }
		        return false;
            

            if (logger.isWarnEnabled()) {
                logger.warn("CommonAnnotationBeanPostProcessor is not registered yet, " +
                        "the method addIntoConfigManager() will be invoked directly");
            }
            
            config.addIntoConfigManager();
        }

DubboConfigAliasPostProcessor 
	BeanPostProcessor postProcessBeforeInitialization

DubboConfigDefaultPropertyValueBeanPostProcessor
	GenericBeanPostProcessorAdapter processBeforeInitialization(AbstractConfig config, String beanName)
		setBeanNameAsDefaultValue(dubboConfigBean, "id", beanName);
			// ....
        setBeanNameAsDefaultValue(dubboConfigBean, "name", beanName);
        	// ....


BeanPostProcessor 相关 对象初始化完成逻辑
// ====================================================================
AbstractConfig addIntoConfigManager()
	ApplicationModel.getConfigManager().addConfig(this); // this ApplicationConfig


BeanPostProcessor 相关 后置逻辑
// ****2 ====================================================================
DubboConfigAliasPostProcessor 
	BeanPostProcessor postProcessAfterInitialization
		if (bean instanceof AbstractConfig) {
            String id = ((AbstractConfig) bean).getId();
            if (hasText(id)                                     // id MUST be present in AbstractConfig
                    && !nullSafeEquals(id, beanName)            // id MUST NOT be equal to bean name
                    && !hasAlias(registry, beanName, id)) {     // id MUST NOT be present in AliasRegistry
                registry.registerAlias(beanName, id);
            }
        }
        return bean;

后面陆续为RegistryConfig、protocolConfig、ServiceBean、HelloServiceImpl（这个不会触发addIntoConfigManager）等 和上面****1~2 一致，不会
// ====================================================================
	// 部分bean含有id的会调用setId方法
	public void setId(String id) {
        this.id = id;
    }



onApplicationEvent(ApplicationEvent event) 逻辑 ， 即ioc和bean全部完成后的逻辑
// ====================================================================

ReferenceAnnotationBeanPostProcessor 
	onApplicationEvent(ApplicationEvent event) {
	    if (event instanceof ContextRefreshedEvent) {
	        referencedBeanNameIdx.entrySet().stream().filter(e -> e.getValue().size() > 1).forEach(e -> {
	            String logPrefix = e.getKey() + " has " + e.getValue().size() + " reference instances, there are: ";
	            logger.warn(e.getValue().stream().collect(Collectors.joining(", ", logPrefix, "")));
	        });
	        referencedBeanNameIdx.clear();
	    }
	}

DubboBootstrapApplicationListener
	onApplicationContextEvent(ApplicationContextEvent event) {
        if (DubboBootstrapStartStopListenerSpringAdapter.applicationContext == null) {
            DubboBootstrapStartStopListenerSpringAdapter.applicationContext = event.getApplicationContext();
        }
        if (event instanceof ContextRefreshedEvent) {
            onContextRefreshedEvent((ContextRefreshedEvent) event);
        } else if (event instanceof ContextClosedEvent) {// ContextStoppedEvent
            onContextClosedEvent((ContextClosedEvent) event);
        }
    }


